{"version":3,"sources":["../src/index.ts","../src/config.ts","../src/router.ts","../src/delegate.ts","../src/tools/diff.ts","../src/tools/tests.ts","../src/tools/docs.ts","../src/providers/anthropic.ts","../src/providers/google.ts","../src/providers/openai.ts","../src/providers/index.ts"],"sourcesContent":["import { Server } from '@modelcontextprotocol/sdk/server.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/stdio.js';\nimport { run, type DelegateContext, type DelegateResult } from './delegate';\nimport type { RouteRequest } from './router';\nimport { createOpenAIProvider } from './providers/openai';\nimport { executeDelegateDiff, type DelegateDiffInput } from './tools/diff';\nimport { executeDelegateTests, type DelegateTestsInput } from './tools/tests';\nimport { executeDelegateDocs, type DelegateDocsInput } from './tools/docs';\nimport { createDelegateContext as buildDelegateContext } from './providers';\n\nconst logger = {\n  debug: (...args: unknown[]) => console.debug('[axcess]', ...args),\n  info: (...args: unknown[]) => console.info('[axcess]', ...args),\n  warn: (...args: unknown[]) => console.warn('[axcess]', ...args),\n  error: (...args: unknown[]) => console.error('[axcess]', ...args),\n};\n\nconst delegateContext: DelegateContext = buildDelegateContext(logger);\n\nconst server = new Server({\n  name: 'axcess-mcp',\n  version: '0.1.0',\n});\n\nserver.tool(\n  'delegate.run',\n  {\n    description: 'Roteia prompts para os modelos configurados e retorna a resposta.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        prompt: {\n          type: 'string',\n          description: 'Prompt a ser encaminhado para o roteador.',\n        },\n        forceModel: {\n          type: 'string',\n          description: 'Modelo ou alias forçado, ignorando heurísticas.',\n        },\n        metadata: {\n          type: 'object',\n          description: 'Metadados opcionais que ajudam no roteamento.',\n          properties: {\n            language: { type: 'string' },\n            tier: { type: 'string' },\n            domain: {\n              type: 'string',\n              enum: ['code', 'creative', 'default'],\n            },\n            temperature: { type: 'number' },\n          },\n          additionalProperties: false,\n        },\n        caps: {\n          type: 'object',\n          description: 'Limites adicionais para a requisição.',\n          properties: {\n            maxOutputTokens: { type: 'number' },\n          },\n          additionalProperties: false,\n        },\n      },\n      required: ['prompt'],\n      additionalProperties: false,\n    },\n  },\n  async ({ input }) => {\n    const request: RouteRequest = {\n      prompt: input.prompt,\n      forceModel: input.forceModel,\n      metadata: input.metadata,\n      caps: input.caps,\n    };\n\n    try {\n      const result = await run(request, delegateContext);\n      logDelegateResult('delegate.run', result);\n\n      return buildToolResponse(result);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      logger.error('delegate.run: falha ao processar request', message);\n      return {\n        isError: true,\n        content: [\n          {\n            type: 'text',\n            text: message,\n          },\n        ],\n      };\n    }\n  }\n);\n\nserver.tool(\n  'delegate.diff',\n  {\n    description: 'Gera um patch unificado (diff --git) a partir de instruções de refatoração.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        instructions: {\n          type: 'string',\n          description: 'Instruções detalhadas para gerar o patch.',\n        },\n        context: { type: 'string' },\n        files: {\n          type: 'array',\n          items: {\n            type: 'object',\n            properties: {\n              path: { type: 'string' },\n              contents: { type: 'string' },\n            },\n            required: ['path', 'contents'],\n            additionalProperties: false,\n          },\n        },\n        language: { type: 'string' },\n        tier: { type: 'string' },\n        temperature: { type: 'number' },\n        forceModel: { type: 'string' },\n        maxOutputTokens: { type: 'number' },\n      },\n      required: ['instructions'],\n      additionalProperties: false,\n    },\n  },\n  async ({ input }) => {\n    try {\n      const result = await executeDelegateDiff(input as DelegateDiffInput, delegateContext);\n      logDelegateResult('delegate.diff', result.result);\n      return buildToolResponse(result.result, result.text);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      logger.error('delegate.diff: falha ao processar request', message);\n      return {\n        isError: true,\n        content: [\n          {\n            type: 'text',\n            text: message,\n          },\n        ],\n      };\n    }\n  }\n);\n\nserver.tool(\n  'delegate.tests',\n  {\n    description: 'Gera comandos e arquivos de teste determinísticos.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        instructions: {\n          type: 'string',\n          description: 'Objetivo e escopo dos testes.',\n        },\n        context: { type: 'string' },\n        language: { type: 'string' },\n        framework: { type: 'string' },\n        tier: { type: 'string' },\n        temperature: { type: 'number' },\n        forceModel: { type: 'string' },\n        maxOutputTokens: { type: 'number' },\n      },\n      required: ['instructions'],\n      additionalProperties: false,\n    },\n  },\n  async ({ input }) => {\n    try {\n      const result = await executeDelegateTests(input as DelegateTestsInput, delegateContext);\n      logDelegateResult('delegate.tests', result.result);\n      return buildToolResponse(result.result, result.text);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      logger.error('delegate.tests: falha ao processar request', message);\n      return {\n        isError: true,\n        content: [\n          {\n            type: 'text',\n            text: message,\n          },\n        ],\n      };\n    }\n  }\n);\n\nserver.tool(\n  'delegate.docs',\n  {\n    description: 'Produz documentação concisa em Markdown.',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        instructions: {\n          type: 'string',\n          description: 'Diretrizes para o documento.',\n        },\n        context: { type: 'string' },\n        audience: { type: 'string' },\n        tone: { type: 'string' },\n        language: { type: 'string' },\n        tier: { type: 'string' },\n        temperature: { type: 'number' },\n        forceModel: { type: 'string' },\n        maxOutputTokens: { type: 'number' },\n      },\n      required: ['instructions'],\n      additionalProperties: false,\n    },\n  },\n  async ({ input }) => {\n    try {\n      const result = await executeDelegateDocs(input as DelegateDocsInput, delegateContext);\n      logDelegateResult('delegate.docs', result.result);\n      return buildToolResponse(result.result, result.text);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      logger.error('delegate.docs: falha ao processar request', message);\n      const normalizedError = normalizeError(error);\n      logger.error('delegate.run: falha ao processar request', normalizedError);\n      return {\n        isError: true,\n        content: [\n          {\n            type: 'text',\n            text: normalizedError.message,\n          },\n        ],\n        metadata: {\n          error: normalizedError,\n        },\n      };\n    }\n  }\n);\n\nfunction buildToolResponse(result: DelegateResult, overrideText?: string) {\n  const text = overrideText ?? result.text;\n  return {\n    content: [\n      {\n        type: 'text',\n        text,\n      },\n    ],\n    metadata: {\n      decision: result.decision,\n      parameters: result.parameters,\n      rationale: result.rationale,\n      usage: result.usage,\n      cost: result.cost,\n      meta: result.meta,\n    },\n  };\n}\n\nfunction logDelegateResult(tool: string, result: DelegateResult): void {\n  if (result.meta.fallback_used) {\n    const attempts = result.meta.attempts\n      .map((attempt) => `${attempt.provider}/${attempt.model}:${attempt.success ? 'ok' : 'fail'}`)\n      .join(', ');\n    logger.warn(`${tool}: fallback utilizado`, attempts);\n  } else {\n    logger.info(`${tool}: rota principal executada`, `${result.decision.provider}/${result.decision.model}`);\n  }\n}\n\nasync function main() {\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n}\n\nvoid main().catch((error) => {\n  const normalizedError = normalizeError(error);\n  logger.error('mcp.startup_failed', normalizedError);\n  throw error;\n});\n\nfunction normalizeError(error: unknown): { message: string; stack?: string; name?: string } {\n  if (error instanceof Error) {\n    return {\n      message: error.message,\n      stack: error.stack,\n      name: error.name,\n    };\n  }\n\n  return { message: String(error) };\n}\n","import { readFileSync } from 'node:fs';\nimport path from 'node:path';\n\nexport interface ModelPricing {\n  currency?: string;\n  input: number;\n  output: number;\n}\n\nexport interface ModelCap {\n  default: number;\n  hard?: number;\n}\n\nexport interface ModelInfo {\n  provider: string;\n  model: string;\n  max_output_tokens: number;\n  temperature?: number;\n  cap: ModelCap;\n  pricing: ModelPricing;\n}\n\nexport interface ModelsConfig {\n  aliases: Record<string, string>;\n  models: Record<string, ModelInfo>;\n}\n\nexport interface LanguageHeuristic {\n  alias?: string;\n  temperature?: number;\n}\n\nexport interface TokenBucketRule {\n  alias: string;\n  minPromptTokens?: number;\n  maxPromptTokens?: number;\n}\n\nexport interface RoutingPolicy {\n  defaultAlias: string;\n  languageHeuristics: Record<string, LanguageHeuristic>;\n  tokenBuckets: TokenBucketRule[];\n  fallbacks: Record<string, string[]>;\n}\n\nexport interface CapsPolicy {\n  default: number;\n  tiers?: Record<string, number>;\n}\n\nexport interface TemperaturesPolicy {\n  default: number;\n  code?: number;\n  creative?: number;\n}\n\nexport interface PoliciesConfig {\n  routing: RoutingPolicy;\n  caps: CapsPolicy;\n  temperatures: TemperaturesPolicy;\n}\n\nlet modelsCache: ModelsConfig | null = null;\nlet policiesCache: PoliciesConfig | null = null;\n\nfunction getConfPath(filename: string): string {\n  return path.resolve(__dirname, '..', 'conf', filename);\n}\n\nfunction assertNumber(value: unknown, message: string): asserts value is number {\n  if (typeof value !== 'number' || Number.isNaN(value)) {\n    throw new Error(message);\n  }\n}\n\nfunction assertObject(value: unknown, message: string): asserts value is Record<string, unknown> {\n  if (!value || typeof value !== 'object' || Array.isArray(value)) {\n    throw new Error(message);\n  }\n}\n\nexport function loadModelsConfig(): ModelsConfig {\n  if (modelsCache) {\n    return modelsCache;\n  }\n\n  const raw = readFileSync(getConfPath('models.json'), 'utf-8');\n  const parsed = JSON.parse(raw) as Partial<ModelsConfig>;\n\n  if (!parsed.aliases || typeof parsed.aliases !== 'object') {\n    throw new Error('models.json: missing aliases map');\n  }\n\n  if (!parsed.models || typeof parsed.models !== 'object') {\n    throw new Error('models.json: missing models map');\n  }\n\n  const aliases: Record<string, string> = {};\n  for (const [alias, modelKey] of Object.entries(parsed.aliases)) {\n    if (typeof alias !== 'string' || alias.trim() === '') {\n      throw new Error(`models.json: invalid alias name \"${alias}\"`);\n    }\n    if (typeof modelKey !== 'string' || modelKey.trim() === '') {\n      throw new Error(`models.json: alias \"${alias}\" has invalid target`);\n    }\n    aliases[alias] = modelKey;\n  }\n\n  const models: Record<string, ModelInfo> = {};\n  for (const [modelKey, value] of Object.entries(parsed.models as Record<string, unknown>)) {\n    assertObject(value, `models.json: model \"${modelKey}\" must be an object`);\n\n    const provider = value.provider;\n    const model = value.model;\n    const maxOutputTokens = value.max_output_tokens;\n    const temperature = value.temperature;\n    const cap = value.cap;\n    const pricing = value.pricing;\n\n    if (typeof provider !== 'string' || provider.trim() === '') {\n      throw new Error(`models.json: model \"${modelKey}\" missing provider`);\n    }\n\n    if (typeof model !== 'string' || model.trim() === '') {\n      throw new Error(`models.json: model \"${modelKey}\" missing model identifier`);\n    }\n\n    assertNumber(maxOutputTokens, `models.json: model \"${modelKey}\" max_output_tokens must be a number`);\n\n    if (temperature !== undefined) {\n      assertNumber(temperature, `models.json: model \"${modelKey}\" temperature must be a number`);\n    }\n\n    assertObject(cap, `models.json: model \"${modelKey}\" cap must be an object`);\n    assertNumber((cap as Record<string, unknown>).default, `models.json: model \"${modelKey}\" cap.default must be a number`);\n    if ((cap as Record<string, unknown>).hard !== undefined) {\n      assertNumber((cap as Record<string, unknown>).hard, `models.json: model \"${modelKey}\" cap.hard must be a number`);\n    }\n\n    assertObject(pricing, `models.json: model \"${modelKey}\" pricing must be an object`);\n    assertNumber((pricing as Record<string, unknown>).input, `models.json: model \"${modelKey}\" pricing.input must be a number`);\n    assertNumber((pricing as Record<string, unknown>).output, `models.json: model \"${modelKey}\" pricing.output must be a number`);\n\n    const pricingCurrency = (pricing as Record<string, unknown>).currency;\n    if (pricingCurrency !== undefined && (typeof pricingCurrency !== 'string' || pricingCurrency.trim() === '')) {\n      throw new Error(`models.json: model \"${modelKey}\" pricing.currency must be a string`);\n    }\n\n    models[modelKey] = {\n      provider,\n      model,\n      max_output_tokens: maxOutputTokens,\n      temperature: temperature as number | undefined,\n      cap: {\n        default: (cap as Record<string, number>).default,\n        hard: (cap as Record<string, number>).hard,\n      },\n      pricing: {\n        currency: pricingCurrency as string | undefined,\n        input: (pricing as Record<string, number>).input,\n        output: (pricing as Record<string, number>).output,\n      },\n    };\n  }\n\n  for (const [alias, modelKey] of Object.entries(aliases)) {\n    if (!models[modelKey]) {\n      throw new Error(`models.json: alias \"${alias}\" aponta para modelo desconhecido \"${modelKey}\"`);\n    }\n  }\n\n  modelsCache = { aliases, models };\n  return modelsCache;\n}\n\nexport function loadPoliciesConfig(): PoliciesConfig {\n  if (policiesCache) {\n    return policiesCache;\n  }\n\n  const raw = readFileSync(getConfPath('policies.json'), 'utf-8');\n  const parsed = JSON.parse(raw) as Partial<PoliciesConfig>;\n\n  if (!parsed.routing) {\n    throw new Error('policies.json: missing routing block');\n  }\n\n  if (!parsed.caps) {\n    throw new Error('policies.json: missing caps block');\n  }\n\n  if (!parsed.temperatures) {\n    throw new Error('policies.json: missing temperatures block');\n  }\n\n  const routing = parsed.routing as RoutingPolicy;\n  if (typeof routing.defaultAlias !== 'string' || routing.defaultAlias.trim() === '') {\n    throw new Error('policies.json: routing.defaultAlias must be a string');\n  }\n\n  if (!routing.languageHeuristics || typeof routing.languageHeuristics !== 'object') {\n    throw new Error('policies.json: routing.languageHeuristics must be an object');\n  }\n\n  if (!Array.isArray(routing.tokenBuckets)) {\n    throw new Error('policies.json: routing.tokenBuckets must be an array');\n  }\n\n  if (!routing.fallbacks || typeof routing.fallbacks !== 'object') {\n    throw new Error('policies.json: routing.fallbacks must be an object');\n  }\n\n  const languageHeuristics: Record<string, LanguageHeuristic> = {};\n  for (const [key, value] of Object.entries(routing.languageHeuristics)) {\n    if (!value || typeof value !== 'object') {\n      throw new Error(`policies.json: routing.languageHeuristics[${key}] must be an object`);\n    }\n    const heuristic: LanguageHeuristic = {};\n    if ((value as Record<string, unknown>).alias !== undefined) {\n      const alias = (value as Record<string, unknown>).alias;\n      if (typeof alias !== 'string' || alias.trim() === '') {\n        throw new Error(`policies.json: routing.languageHeuristics[${key}].alias must be a string`);\n      }\n      heuristic.alias = alias;\n    }\n    if ((value as Record<string, unknown>).temperature !== undefined) {\n      assertNumber((value as Record<string, unknown>).temperature, `policies.json: routing.languageHeuristics[${key}].temperature must be a number`);\n      heuristic.temperature = (value as Record<string, number>).temperature;\n    }\n    languageHeuristics[key] = heuristic;\n  }\n\n  const tokenBuckets: TokenBucketRule[] = routing.tokenBuckets.map((bucket, idx) => {\n    if (!bucket || typeof bucket !== 'object') {\n      throw new Error(`policies.json: routing.tokenBuckets[${idx}] must be an object`);\n    }\n    if (typeof bucket.alias !== 'string' || bucket.alias.trim() === '') {\n      throw new Error(`policies.json: routing.tokenBuckets[${idx}].alias must be a string`);\n    }\n    const rule: TokenBucketRule = { alias: bucket.alias };\n    if (bucket.minPromptTokens !== undefined) {\n      assertNumber(bucket.minPromptTokens, `policies.json: routing.tokenBuckets[${idx}].minPromptTokens must be a number`);\n      rule.minPromptTokens = bucket.minPromptTokens;\n    }\n    if (bucket.maxPromptTokens !== undefined) {\n      assertNumber(bucket.maxPromptTokens, `policies.json: routing.tokenBuckets[${idx}].maxPromptTokens must be a number`);\n      rule.maxPromptTokens = bucket.maxPromptTokens;\n    }\n    return rule;\n  });\n\n  const fallbacks: Record<string, string[]> = {};\n  for (const [alias, list] of Object.entries(routing.fallbacks)) {\n    if (!Array.isArray(list)) {\n      throw new Error(`policies.json: routing.fallbacks[${alias}] must be an array`);\n    }\n    fallbacks[alias] = list.filter((value) => typeof value === 'string' && value.trim() !== '');\n  }\n\n  const caps = parsed.caps as CapsPolicy;\n  assertNumber(caps.default, 'policies.json: caps.default must be a number');\n  if (caps.tiers) {\n    for (const [tier, limit] of Object.entries(caps.tiers)) {\n      assertNumber(limit, `policies.json: caps.tiers.${tier} must be a number`);\n    }\n  }\n\n  const temperatures = parsed.temperatures as TemperaturesPolicy;\n  assertNumber(temperatures.default, 'policies.json: temperatures.default must be a number');\n  if (temperatures.code !== undefined) {\n    assertNumber(temperatures.code, 'policies.json: temperatures.code must be a number');\n  }\n  if (temperatures.creative !== undefined) {\n    assertNumber(temperatures.creative, 'policies.json: temperatures.creative must be a number');\n  }\n\n  policiesCache = {\n    routing: {\n      defaultAlias: routing.defaultAlias,\n      languageHeuristics,\n      tokenBuckets,\n      fallbacks,\n    },\n    caps,\n    temperatures,\n  };\n\n  return policiesCache;\n}\n","import { loadModelsConfig, loadPoliciesConfig, ModelInfo } from './config';\n\nexport interface RouteCapsRequest {\n  maxOutputTokens?: number;\n}\n\nexport type RequestDomain = 'code' | 'creative' | 'default';\n\nexport interface RouteMetadata {\n  language?: string;\n  tier?: string;\n  domain?: RequestDomain;\n  temperature?: number;\n}\n\nexport interface RouteRequest {\n  prompt: string;\n  forceModel?: string;\n  caps?: RouteCapsRequest;\n  metadata?: RouteMetadata;\n}\n\nexport interface RouteDecision {\n  alias: string;\n  modelId: string;\n  provider: string;\n  model: string;\n}\n\nexport interface RouteParameters {\n  max_output_tokens: number;\n  temperature: number;\n}\n\nexport interface RouteUsage {\n  estimated_input_tokens: number;\n}\n\nexport interface RouteResult {\n  decision: RouteDecision;\n  parameters: RouteParameters;\n  rationale: string[];\n  fallbacks: RouteDecision[];\n  usage: RouteUsage;\n  meta: {\n    target_max_output_tokens: number;\n  };\n}\n\nconst MIN_TEMPERATURE = 0;\nconst MAX_TEMPERATURE = 2;\n\nfunction clamp(value: number, min: number, max: number): number {\n  return Math.min(Math.max(value, min), max);\n}\n\nfunction normalizeLanguageCode(language?: string): string | undefined {\n  if (!language) {\n    return undefined;\n  }\n  const normalized = language.trim().toLowerCase();\n  if (!normalized) {\n    return undefined;\n  }\n  if (normalized.startsWith('pt')) {\n    return 'pt';\n  }\n  if (normalized.startsWith('en')) {\n    return 'en';\n  }\n  if (normalized.startsWith('es')) {\n    return 'es';\n  }\n  return normalized;\n}\n\nfunction detectLanguage(text: string): string | undefined {\n  const sample = text.slice(0, 512).toLowerCase();\n  if (!sample) {\n    return undefined;\n  }\n\n  let scorePt = 0;\n  let scoreEs = 0;\n  let scoreEn = 0;\n\n  if (/[ãõçáéíóúâêôà]/u.test(sample)) {\n    scorePt += 2;\n  }\n  if (/[ñáéíóúü¿¡]/u.test(sample)) {\n    scoreEs += 2;\n  }\n  if (/\\b(the|and|you|with|for|this|that)\\b/u.test(sample)) {\n    scoreEn += 2;\n  }\n  if (/\\bque\\b/u.test(sample)) {\n    scorePt += 1;\n    scoreEs += 1;\n  }\n  if (/\\bnão\\b|\\bpois\\b|\\bassim\\b/u.test(sample)) {\n    scorePt += 1;\n  }\n  if (/\\busted\\b|\\bpara\\b|\\bcuando\\b/u.test(sample)) {\n    scoreEs += 1;\n  }\n  if (/\\bwill\\b|\\bshould\\b|\\bcan\\b/u.test(sample)) {\n    scoreEn += 1;\n  }\n\n  const scores: Array<{ code: string; score: number }> = [\n    { code: 'pt', score: scorePt },\n    { code: 'es', score: scoreEs },\n    { code: 'en', score: scoreEn },\n  ];\n\n  scores.sort((a, b) => b.score - a.score);\n  if (scores[0].score === 0 || (scores[0].score === scores[1].score)) {\n    return undefined;\n  }\n  return scores[0].code;\n}\n\nfunction estimateTokens(text: string): number {\n  if (!text) {\n    return 0;\n  }\n  return Math.max(1, Math.ceil(text.length / 3));\n}\n\ninterface ResolvedModel {\n  decision: RouteDecision;\n  modelInfo: ModelInfo;\n}\n\nfunction resolveModel(target: string, rationale: string[]): ResolvedModel {\n  const modelsConfig = loadModelsConfig();\n  const modelKeyFromAlias = modelsConfig.aliases[target];\n  if (modelKeyFromAlias) {\n    const modelInfo = modelsConfig.models[modelKeyFromAlias];\n    if (!modelInfo) {\n      throw new Error(`Alias \"${target}\" aponta para modelo inexistente \"${modelKeyFromAlias}\"`);\n    }\n    rationale.push(`Alias \"${target}\" resolve para ${modelInfo.provider}/${modelInfo.model}.`);\n    return {\n      decision: {\n        alias: target,\n        modelId: modelKeyFromAlias,\n        provider: modelInfo.provider,\n        model: modelInfo.model,\n      },\n      modelInfo,\n    };\n  }\n\n  const modelInfo = modelsConfig.models[target];\n  if (modelInfo) {\n    const aliasEntry = Object.entries(modelsConfig.aliases).find(([, modelId]) => modelId === target);\n    const alias = aliasEntry ? aliasEntry[0] : target;\n    rationale.push(`Modelo \"${target}\" será usado diretamente (${modelInfo.provider}/${modelInfo.model}).`);\n    return {\n      decision: {\n        alias,\n        modelId: target,\n        provider: modelInfo.provider,\n        model: modelInfo.model,\n      },\n      modelInfo,\n    };\n  }\n\n  throw new Error(`Modelo ou alias desconhecido: ${target}`);\n}\n\nfunction selectAliasByBucket(estimatedTokens: number): string | undefined {\n  const { tokenBuckets } = loadPoliciesConfig().routing;\n  for (const bucket of tokenBuckets) {\n    const min = bucket.minPromptTokens ?? 0;\n    const max = bucket.maxPromptTokens ?? Number.POSITIVE_INFINITY;\n    if (estimatedTokens >= min && estimatedTokens < max) {\n      return bucket.alias;\n    }\n  }\n  return undefined;\n}\n\nfunction applyCapLimits(target: number, modelInfo: ModelInfo): number {\n  const values: number[] = [target, modelInfo.cap.default, modelInfo.max_output_tokens];\n  if (typeof modelInfo.cap.hard === 'number') {\n    values.push(modelInfo.cap.hard);\n  }\n  const filtered = values.filter((value) => Number.isFinite(value) && value > 0);\n  const candidate = Math.min(...filtered);\n  return Math.max(1, Math.floor(candidate));\n}\n\nexport function routeRequest(request: RouteRequest): RouteResult {\n  if (!request || typeof request.prompt !== 'string') {\n    throw new Error('routeRequest: prompt ausente');\n  }\n\n  const modelsConfig = loadModelsConfig();\n  const policies = loadPoliciesConfig();\n  const rationale: string[] = [];\n\n  const estimatedTokens = estimateTokens(request.prompt);\n  rationale.push(`Estimativa de tokens de entrada: ~${estimatedTokens}.`);\n\n  const metadata = request.metadata ?? {};\n  const normalizedLanguage = normalizeLanguageCode(metadata.language) ?? detectLanguage(request.prompt);\n  if (normalizedLanguage) {\n    rationale.push(`Idioma considerado: ${normalizedLanguage}.`);\n  }\n\n  let selectedAlias = policies.routing.defaultAlias;\n  rationale.push(`Alias padrão da política: ${selectedAlias}.`);\n\n  if (request.forceModel) {\n    rationale.push(`forceModel recebido: ${request.forceModel}.`);\n    const resolved = resolveModel(request.forceModel, rationale);\n    const policyCap = resolvePolicyCap(metadata.tier, rationale);\n    const targetCap = applyRequestCaps(policyCap, request.caps, rationale);\n    const maxOutputTokens = applyCapLimits(targetCap, resolved.modelInfo);\n    const temperature = resolveTemperature(metadata, resolved.modelInfo, rationale);\n\n    const fallbackDecisions = resolveFallbacks(resolved.decision.alias, rationale);\n\n    return {\n      decision: resolved.decision,\n      parameters: {\n        max_output_tokens: maxOutputTokens,\n        temperature,\n      },\n      rationale,\n      fallbacks: fallbackDecisions,\n      usage: {\n        estimated_input_tokens: estimatedTokens,\n      },\n      meta: {\n        target_max_output_tokens: targetCap,\n      },\n    };\n  }\n\n  const bucketAlias = selectAliasByBucket(estimatedTokens);\n  if (bucketAlias) {\n    selectedAlias = bucketAlias;\n    rationale.push(`Bucket de tokens selecionou alias ${bucketAlias}.`);\n  }\n\n  let temperatureOverride: number | undefined;\n  if (normalizedLanguage) {\n    const languagePolicy = policies.routing.languageHeuristics[normalizedLanguage];\n    if (languagePolicy) {\n      if (languagePolicy.alias && languagePolicy.alias !== selectedAlias) {\n        selectedAlias = languagePolicy.alias;\n        rationale.push(`Heurística de idioma ajustou alias para ${selectedAlias}.`);\n      }\n      if (typeof languagePolicy.temperature === 'number') {\n        temperatureOverride = languagePolicy.temperature;\n        rationale.push(`Heurística de idioma sugeriu temperatura ${languagePolicy.temperature}.`);\n      }\n    }\n  }\n\n  const resolved = resolveModel(selectedAlias, rationale);\n  const policyCap = resolvePolicyCap(metadata.tier, rationale);\n  const targetCap = applyRequestCaps(policyCap, request.caps, rationale);\n  const maxOutputTokens = applyCapLimits(targetCap, resolved.modelInfo);\n  const temperature = resolveTemperature(metadata, resolved.modelInfo, rationale, temperatureOverride);\n  const fallbacks = resolveFallbacks(resolved.decision.alias, rationale);\n\n  return {\n    decision: resolved.decision,\n    parameters: {\n      max_output_tokens: maxOutputTokens,\n      temperature,\n    },\n    rationale,\n    fallbacks,\n    usage: {\n      estimated_input_tokens: estimatedTokens,\n    },\n    meta: {\n      target_max_output_tokens: targetCap,\n    },\n  };\n}\n\nfunction resolvePolicyCap(tier: string | undefined, rationale: string[]): number {\n  const policies = loadPoliciesConfig();\n  let limit = policies.caps.default;\n  if (tier) {\n    const normalizedTier = tier.trim().toLowerCase();\n    const tierCap = policies.caps.tiers?.[normalizedTier];\n    if (tierCap) {\n      rationale.push(`Cap de tier \"${normalizedTier}\": ${tierCap}.`);\n      limit = tierCap;\n    } else {\n      rationale.push(`Tier \"${normalizedTier}\" sem cap específico, usando padrão ${limit}.`);\n    }\n  } else {\n    rationale.push(`Cap padrão aplicado: ${limit}.`);\n  }\n  return limit;\n}\n\nfunction applyRequestCaps(policyCap: number, caps: RouteCapsRequest | undefined, rationale: string[]): number {\n  let target = policyCap;\n  if (caps?.maxOutputTokens && caps.maxOutputTokens > 0) {\n    target = Math.min(target, caps.maxOutputTokens);\n    rationale.push(`Cap solicitado na requisição: ${caps.maxOutputTokens}.`);\n  }\n  return target;\n}\n\nfunction resolveTemperature(\n  metadata: RouteMetadata,\n  modelInfo: ModelInfo,\n  rationale: string[],\n  languageOverride?: number,\n): number {\n  const policies = loadPoliciesConfig();\n  let temperature = typeof modelInfo.temperature === 'number' ? modelInfo.temperature : policies.temperatures.default;\n  rationale.push(`Temperatura base do modelo/política: ${temperature}.`);\n\n  if (typeof languageOverride === 'number') {\n    temperature = languageOverride;\n    rationale.push(`Temperatura ajustada pela heurística de idioma: ${temperature}.`);\n  }\n\n  if (metadata.domain) {\n    const domainTemp = (policies.temperatures as Record<string, number | undefined>)[metadata.domain];\n    if (typeof domainTemp === 'number') {\n      temperature = domainTemp;\n      rationale.push(`Temperatura ajustada pelo domínio \"${metadata.domain}\": ${temperature}.`);\n    }\n  }\n\n  if (typeof metadata.temperature === 'number') {\n    temperature = metadata.temperature;\n    rationale.push(`Temperatura explicitamente definida na requisição: ${temperature}.`);\n  }\n\n  temperature = clamp(temperature, MIN_TEMPERATURE, MAX_TEMPERATURE);\n  rationale.push(`Temperatura final após clamp: ${temperature}.`);\n  return temperature;\n}\n\nfunction resolveFallbacks(primaryAlias: string, rationale: string[]): RouteDecision[] {\n  const policies = loadPoliciesConfig();\n  const fallbacks = policies.routing.fallbacks[primaryAlias] ?? [];\n  const decisions: RouteDecision[] = [];\n  const seen = new Set<string>([primaryAlias]);\n\n  for (const alias of fallbacks) {\n    if (seen.has(alias)) {\n      continue;\n    }\n    try {\n      const resolved = resolveModel(alias, rationale);\n      decisions.push(resolved.decision);\n      seen.add(alias);\n    } catch (error) {\n      rationale.push(`Fallback ignorado \"${alias}\": ${(error as Error).message}.`);\n    }\n  }\n\n  if (decisions.length) {\n    rationale.push(`Fallbacks disponíveis: ${decisions.map((item) => item.alias).join(', ')}.`);\n  } else {\n    rationale.push('Nenhum fallback configurado para o alias selecionado.');\n  }\n\n  return decisions;\n}\n\nexport function computeMaxTokensForModel(targetCap: number, modelId: string): number {\n  const modelsConfig = loadModelsConfig();\n  const modelInfo = modelsConfig.models[modelId];\n  if (!modelInfo) {\n    throw new Error(`Modelo desconhecido: ${modelId}`);\n  }\n  return applyCapLimits(targetCap, modelInfo);\n}\n","import { loadModelsConfig } from './config';\nimport { computeMaxTokensForModel, routeRequest, RouteDecision, RouteParameters, RouteRequest, RouteResult } from './router';\n\nexport interface ProviderUsage {\n  inputTokens?: number;\n  outputTokens?: number;\n  totalTokens?: number;\n}\n\nexport interface ProviderResponse {\n  outputText: string;\n  usage?: ProviderUsage;\n  raw?: unknown;\n}\n\nexport interface ProviderCallArgs {\n  prompt: string;\n  decision: RouteDecision;\n  parameters: RouteParameters;\n  request: RouteRequest;\n}\n\nexport type ProviderHandler = (args: ProviderCallArgs) => Promise<ProviderResponse>;\n\nexport interface DelegateContext {\n  providers: Record<string, ProviderHandler>;\n  logger?: {\n    debug?: (...args: unknown[]) => void;\n    info?: (...args: unknown[]) => void;\n    warn?: (...args: unknown[]) => void;\n    error?: (...args: unknown[]) => void;\n  };\n}\n\nexport interface AttemptLog {\n  alias: string;\n  provider: string;\n  model: string;\n  success: boolean;\n  error?: string;\n}\n\nexport interface DelegateResult {\n  text: string;\n  decision: RouteDecision;\n  parameters: RouteParameters;\n  rationale: string[];\n  usage: {\n    estimated_input_tokens: number;\n    input_tokens: number;\n    output_tokens: number;\n    total_tokens: number;\n  };\n  cost: {\n    currency: string;\n    input: number;\n    output: number;\n    total: number;\n  };\n  meta: {\n    rawResponse?: unknown;\n    fallback_used: boolean;\n    attempts: AttemptLog[];\n  };\n}\n\nfunction sanitizeTokens(value: number | undefined): number | undefined {\n  if (typeof value !== 'number' || Number.isNaN(value)) {\n    return undefined;\n  }\n  return Math.max(0, Math.round(value));\n}\n\nexport async function run(request: RouteRequest, context: DelegateContext): Promise<DelegateResult> {\n  if (!context?.providers) {\n    throw new Error('delegate.run: nenhum provider registrado');\n  }\n\n  const routing: RouteResult = routeRequest(request);\n  const modelsConfig = loadModelsConfig();\n  const attempts: AttemptLog[] = [];\n  const candidates: RouteDecision[] = [routing.decision, ...routing.fallbacks];\n  const errors: string[] = [];\n  const logger = context.logger;\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const decision = candidates[index];\n    const providerHandler = context.providers[decision.provider];\n    const attemptEntry: AttemptLog = {\n      alias: decision.alias,\n      provider: decision.provider,\n      model: decision.model,\n      success: false,\n    };\n\n    if (!providerHandler) {\n      const message = `Provider \"${decision.provider}\" não registrado.`;\n      attemptEntry.error = message;\n      attempts.push(attemptEntry);\n      errors.push(message);\n      logger?.warn?.(message);\n      continue;\n    }\n\n    const cappedMaxTokens = computeMaxTokensForModel(routing.meta.target_max_output_tokens, decision.modelId);\n    const parameters: RouteParameters = {\n      max_output_tokens: cappedMaxTokens,\n      temperature: routing.parameters.temperature,\n    };\n\n    try {\n      const response = await providerHandler({\n        prompt: request.prompt,\n        decision,\n        parameters,\n        request,\n      });\n\n      const providerUsage = response.usage ?? {};\n      const estimatedInputTokens = routing.usage.estimated_input_tokens;\n      const sanitizedInput = sanitizeTokens(providerUsage.inputTokens);\n      const sanitizedOutput = sanitizeTokens(providerUsage.outputTokens);\n      const sanitizedTotal = sanitizeTokens(providerUsage.totalTokens);\n\n      const onlyTotalProvided =\n        sanitizedTotal !== undefined && sanitizedInput === undefined && sanitizedOutput === undefined;\n\n      const tokenFallbackNotes: string[] = [];\n      let inputTokens = sanitizedInput ?? estimatedInputTokens;\n      let outputTokens = sanitizedOutput ?? 0;\n\n      if (onlyTotalProvided) {\n        inputTokens = sanitizedTotal!;\n        outputTokens = 0;\n        const message =\n          'Provider informou apenas totalTokens; assumindo total como input_tokens e output_tokens=0.';\n        tokenFallbackNotes.push(message);\n        logger?.debug?.(\n          'delegate.run: somente totalTokens fornecido; adotando input=%d e output=%d para cálculo de custos.',\n          inputTokens,\n          outputTokens,\n        );\n      } else {\n        if (sanitizedInput === undefined && sanitizedTotal !== undefined) {\n          inputTokens = Math.max(sanitizedTotal - outputTokens, 0);\n        }\n\n        if (sanitizedOutput === undefined && sanitizedTotal !== undefined) {\n          outputTokens = Math.max(sanitizedTotal - inputTokens, 0);\n        }\n      }\n\n      const totalTokens = sanitizedTotal ?? inputTokens + outputTokens;\n\n      const modelInfo = modelsConfig.models[decision.modelId];\n      if (!modelInfo) {\n        throw new Error(`Modelo ${decision.modelId} não encontrado na configuração.`);\n      }\n\n      const currency = modelInfo.pricing.currency ?? 'USD';\n      const inputCost = inputTokens * modelInfo.pricing.input;\n      const outputCost = outputTokens * modelInfo.pricing.output;\n      const totalCost = inputCost + outputCost;\n\n      attemptEntry.success = true;\n      attempts.push(attemptEntry);\n\n      const fallbackUsed = index > 0;\n      const rationale = [...routing.rationale, ...tokenFallbackNotes];\n      if (fallbackUsed) {\n        rationale.push(`Fallback usado: ${decision.alias}.`);\n      }\n\n      logger?.info?.(`delegate.run: chamada bem sucedida com ${decision.provider}/${decision.model}.`);\n\n      return {\n        text: response.outputText,\n        decision,\n        parameters,\n        rationale,\n        usage: {\n          estimated_input_tokens: estimatedInputTokens,\n          input_tokens: inputTokens,\n          output_tokens: outputTokens,\n          total_tokens: totalTokens,\n        },\n        cost: {\n          currency,\n          input: inputCost,\n          output: outputCost,\n          total: totalCost,\n        },\n        meta: {\n          rawResponse: response.raw,\n          fallback_used: fallbackUsed,\n          attempts,\n        },\n      };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      attemptEntry.error = message;\n      attempts.push(attemptEntry);\n      errors.push(message);\n      logger?.error?.(`delegate.run: erro ao chamar ${decision.provider}/${decision.model}: ${message}`);\n    }\n  }\n\n  const errorMessage = `delegate.run: todas as tentativas falharam (${errors.join('; ')}).`;\n  throw new Error(errorMessage);\n}\n","import { run, type DelegateContext, type DelegateResult } from '../delegate';\nimport type { RouteMetadata, RouteRequest } from '../router';\n\nexport interface DiffFileContext {\n  path: string;\n  contents: string;\n}\n\nexport interface DelegateDiffInput {\n  instructions: string;\n  context?: string;\n  files?: DiffFileContext[];\n  language?: string;\n  tier?: string;\n  temperature?: number;\n  forceModel?: string;\n  maxOutputTokens?: number;\n}\n\nexport interface ToolExecutionResult {\n  text: string;\n  result: DelegateResult;\n}\n\nfunction buildFileContext(files: DiffFileContext[] | undefined): string {\n  if (!files?.length) {\n    return '';\n  }\n\n  const rendered = files\n    .map((file) => {\n      const header = `File: ${file.path}`;\n      const separator = '-'.repeat(header.length);\n      const body = file.contents.trimEnd();\n      return `${header}\\n${separator}\\n${body}`;\n    })\n    .join('\\n\\n');\n\n  return `\\nProvided files:\\n${rendered}`;\n}\n\nfunction stripCodeFences(text: string): string {\n  const trimmed = text.trim();\n  const fencePattern = /^```[a-zA-Z0-9:-]*\\n([\\s\\S]*?)\\n```$/;\n  const match = trimmed.match(fencePattern);\n  if (match) {\n    return match[1].trim();\n  }\n  return trimmed;\n}\n\nfunction validateDiffOutput(diffText: string): void {\n  if (!diffText.startsWith('diff --git ')) {\n    throw new Error('delegate.diff: resposta não contém patch unificado iniciando com \"diff --git\".');\n  }\n  if (!diffText.includes('\\n@@')) {\n    throw new Error('delegate.diff: patch sem hunks @@ inválido.');\n  }\n}\n\nfunction buildPrompt(input: DelegateDiffInput): string {\n  const baseInstructions = [\n    'You are delegate.diff, an assistant that returns Git patches.',\n    'Respond with a unified diff using \"diff --git\" headers and @@ hunks.',\n    'Do not include explanations, commentary, or code fences.',\n    'Only include files that actually change.',\n    'Use LF line endings and preserve existing indentation.',\n    'If no change is required, return an empty diff that only contains diff --git headers with no modifications.',\n  ].join('\\n');\n\n  const supplementalContext = input.context ? `\\nAdditional context:\\n${input.context.trim()}` : '';\n  const fileContext = buildFileContext(input.files);\n\n  return `${baseInstructions}${supplementalContext}${fileContext}\\n\\nUser instructions:\\n${input.instructions.trim()}\\n`;\n}\n\nfunction buildRouteRequest(input: DelegateDiffInput, prompt: string): RouteRequest {\n  const metadata: RouteMetadata = {\n    language: input.language,\n    domain: 'code',\n    tier: input.tier,\n    temperature: input.temperature,\n  };\n\n  const caps = typeof input.maxOutputTokens === 'number' && input.maxOutputTokens > 0\n    ? { maxOutputTokens: input.maxOutputTokens }\n    : undefined;\n\n  return {\n    prompt,\n    forceModel: input.forceModel,\n    metadata,\n    caps,\n  };\n}\n\nexport async function executeDelegateDiff(input: DelegateDiffInput, context: DelegateContext): Promise<ToolExecutionResult> {\n  if (!input?.instructions?.trim()) {\n    throw new Error('delegate.diff: campo \"instructions\" é obrigatório.');\n  }\n\n  const prompt = buildPrompt(input);\n  const request = buildRouteRequest(input, prompt);\n  const runResult = await run(request, context);\n  const sanitized = stripCodeFences(runResult.text);\n  validateDiffOutput(sanitized);\n\n  const result: DelegateResult = {\n    ...runResult,\n    text: sanitized,\n  };\n\n  return {\n    text: sanitized,\n    result,\n  };\n}\n","import { run, type DelegateContext, type DelegateResult } from '../delegate';\nimport type { RouteMetadata, RouteRequest } from '../router';\n\nexport interface DelegateTestsInput {\n  instructions: string;\n  context?: string;\n  language?: string;\n  framework?: string;\n  tier?: string;\n  temperature?: number;\n  forceModel?: string;\n  maxOutputTokens?: number;\n}\n\nexport interface TestsToolResult {\n  text: string;\n  result: DelegateResult;\n}\n\nfunction buildPrompt(input: DelegateTestsInput): string {\n  const rules = [\n    'You are delegate.tests, an assistant that designs deterministic testing plans.',\n    'Return Markdown with exactly two sections: \"## Commands\" and \"## Files\" in this order.',\n    'In \"## Commands\" list shell commands using bullet points with inline code.',\n    'In \"## Files\" provide one or more fenced code blocks labelled with the file path, like ```path/to/file.ext`.',\n    'Use deterministic seeds and avoid external services.',\n    'Do not add commentary outside of these sections.',\n  ].join('\\n');\n\n  const frameworkNote = input.framework ? `\\nPreferred framework: ${input.framework.trim()}.` : '';\n  const extraContext = input.context ? `\\nContext:\\n${input.context.trim()}` : '';\n\n  return `${rules}${frameworkNote}${extraContext}\\n\\nUser instructions:\\n${input.instructions.trim()}\\n`;\n}\n\nfunction buildRouteRequest(input: DelegateTestsInput, prompt: string): RouteRequest {\n  const metadata: RouteMetadata = {\n    language: input.language,\n    domain: 'code',\n    tier: input.tier,\n    temperature: input.temperature,\n  };\n\n  const caps = typeof input.maxOutputTokens === 'number' && input.maxOutputTokens > 0\n    ? { maxOutputTokens: input.maxOutputTokens }\n    : undefined;\n\n  return {\n    prompt,\n    forceModel: input.forceModel,\n    metadata,\n    caps,\n  };\n}\n\nfunction sanitizeOutput(text: string): string {\n  return text.trim();\n}\n\nfunction validateTestsOutput(text: string): void {\n  if (!/^## Commands/m.test(text)) {\n    throw new Error('delegate.tests: seção \"## Commands\" ausente.');\n  }\n  if (!/^## Files/m.test(text)) {\n    throw new Error('delegate.tests: seção \"## Files\" ausente.');\n  }\n  const filesIndex = text.indexOf('## Files');\n  const commandsSegment = filesIndex >= 0 ? text.slice(0, filesIndex) : text;\n  if (!/`[^`\\n]+`/.test(commandsSegment)) {\n    throw new Error('delegate.tests: nenhuma linha de comando detectada na seção Commands.');\n  }\n  const filesSection = filesIndex >= 0 ? text.slice(filesIndex) : '';\n  if (!/```[^\\n]*\\n[\\s\\S]+?```/m.test(filesSection)) {\n    throw new Error('delegate.tests: nenhuma code block de arquivo detectada.');\n  }\n}\n\nexport async function executeDelegateTests(input: DelegateTestsInput, context: DelegateContext): Promise<TestsToolResult> {\n  if (!input?.instructions?.trim()) {\n    throw new Error('delegate.tests: campo \"instructions\" é obrigatório.');\n  }\n\n  const prompt = buildPrompt(input);\n  const request = buildRouteRequest(input, prompt);\n  const runResult = await run(request, context);\n  const sanitized = sanitizeOutput(runResult.text);\n  validateTestsOutput(sanitized);\n\n  const result: DelegateResult = {\n    ...runResult,\n    text: sanitized,\n  };\n\n  return {\n    text: sanitized,\n    result,\n  };\n}\n","import { run, type DelegateContext, type DelegateResult } from '../delegate';\nimport type { RouteMetadata, RouteRequest } from '../router';\n\nexport interface DelegateDocsInput {\n  instructions: string;\n  context?: string;\n  audience?: string;\n  tone?: string;\n  language?: string;\n  tier?: string;\n  temperature?: number;\n  forceModel?: string;\n  maxOutputTokens?: number;\n}\n\nexport interface DocsToolResult {\n  text: string;\n  result: DelegateResult;\n}\n\nfunction buildPrompt(input: DelegateDocsInput): string {\n  const rules = [\n    'You are delegate.docs, a technical writer producing concise Markdown.',\n    'Return a short document under 200 lines.',\n    'Begin with a single H1 heading summarizing the document.',\n    'Organize content into focused sections using H2 or H3 headings.',\n    'Avoid introductions, apologies, or filler text.',\n    'Use bullet lists only when conveying steps or key points.',\n    'Do not include code fences unless strictly necessary for snippets.',\n  ].join('\\n');\n\n  const audienceLine = input.audience ? `\\nTarget audience: ${input.audience.trim()}.` : '';\n  const toneLine = input.tone ? `\\nTone: ${input.tone.trim()}.` : '';\n  const extraContext = input.context ? `\\nContext:\\n${input.context.trim()}` : '';\n\n  return `${rules}${audienceLine}${toneLine}${extraContext}\\n\\nUser instructions:\\n${input.instructions.trim()}\\n`;\n}\n\nfunction buildRouteRequest(input: DelegateDocsInput, prompt: string): RouteRequest {\n  const metadata: RouteMetadata = {\n    language: input.language,\n    domain: 'default',\n    tier: input.tier,\n    temperature: input.temperature,\n  };\n\n  const caps = typeof input.maxOutputTokens === 'number' && input.maxOutputTokens > 0\n    ? { maxOutputTokens: input.maxOutputTokens }\n    : undefined;\n\n  return {\n    prompt,\n    forceModel: input.forceModel,\n    metadata,\n    caps,\n  };\n}\n\nfunction sanitizeDocsOutput(text: string): string {\n  return text.trim();\n}\n\nfunction validateDocsOutput(text: string): void {\n  if (!text.startsWith('# ')) {\n    throw new Error('delegate.docs: documento deve iniciar com heading H1.');\n  }\n  const lineCount = text.split(/\\r?\\n/).length;\n  if (lineCount > 200) {\n    throw new Error('delegate.docs: documento excedeu o limite de 200 linhas.');\n  }\n}\n\nexport async function executeDelegateDocs(input: DelegateDocsInput, context: DelegateContext): Promise<DocsToolResult> {\n  if (!input?.instructions?.trim()) {\n    throw new Error('delegate.docs: campo \"instructions\" é obrigatório.');\n  }\n\n  const prompt = buildPrompt(input);\n  const request = buildRouteRequest(input, prompt);\n  const runResult = await run(request, context);\n  const sanitized = sanitizeDocsOutput(runResult.text);\n  validateDocsOutput(sanitized);\n\n  const result: DelegateResult = {\n    ...runResult,\n    text: sanitized,\n  };\n\n  return {\n    text: sanitized,\n    result,\n  };\n}\n","import Anthropic, { APIError as AnthropicAPIError } from '@anthropic-ai/sdk';\nimport type { ProviderHandler } from '../delegate';\n\nexport interface AnthropicProviderOptions {\n  apiKey?: string;\n}\n\nfunction buildAnthropicClient(apiKey?: string): Anthropic | null {\n  if (!apiKey || apiKey.trim() === '') {\n    return null;\n  }\n  return new Anthropic({ apiKey });\n}\n\nfunction normalizeAnthropicError(error: unknown): Error {\n  if (error instanceof AnthropicAPIError) {\n    if (error.status === 401 || error.status === 403) {\n      return new Error('anthropic: falha de autenticação. Confere ANTHROPIC_API_KEY e escopos.');\n    }\n    if (error.status === 408) {\n      return new Error('anthropic: tempo limite excedido. Bora tentar o fallback.');\n    }\n    if (error.status === 429) {\n      return new Error('anthropic: limite de requisições atingido. Segura um pouco e tenta de novo.');\n    }\n    return new Error(`anthropic: ${error.message}`);\n  }\n\n  if (error instanceof Error) {\n    const code = (error as NodeJS.ErrnoException).code;\n    if (code === 'ETIMEDOUT' || code === 'ESOCKETTIMEDOUT') {\n      return new Error('anthropic: conexão expirou. Vamos chamar o próximo da fila.');\n    }\n    return new Error(`anthropic: ${error.message}`);\n  }\n\n  return new Error(`anthropic: falha inesperada (${String(error)})`);\n}\n\nexport function createAnthropicProvider(options?: AnthropicProviderOptions): ProviderHandler {\n  const client = buildAnthropicClient(options?.apiKey);\n\n  return async ({ prompt, decision, parameters }) => {\n    if (!client) {\n      throw new Error('anthropic: chave de API não configurada. Define ANTHROPIC_API_KEY.');\n    }\n\n    try {\n      const response = await client.responses.create({\n        model: decision.model,\n        max_output_tokens: parameters.max_output_tokens,\n        temperature: parameters.temperature,\n        input: prompt,\n      });\n\n      const outputText = typeof response.output_text === 'string'\n        ? response.output_text\n        : Array.isArray(response.output)\n          ? response.output\n              .map((item) => {\n                if (item.type === 'output_text' && typeof item.text === 'string') {\n                  return item.text;\n                }\n                return '';\n              })\n              .join('')\n          : '';\n\n      return {\n        outputText,\n        usage: {\n          inputTokens: response.usage?.input_tokens,\n          outputTokens: response.usage?.output_tokens,\n          totalTokens: response.usage?.total_tokens,\n        },\n        raw: response,\n      };\n    } catch (error) {\n      throw normalizeAnthropicError(error);\n    }\n  };\n}\n","import { GenerativeServiceClient, type GenerateContentResponse } from '@google-ai/generativelanguage';\nimport { GoogleAuth } from 'google-auth-library';\nimport type { ProviderHandler } from '../delegate';\n\nexport interface GoogleProviderOptions {\n  apiKey?: string;\n}\n\ntype GoogleClientPromise = Promise<GenerativeServiceClient>;\n\nfunction ensureModelName(model: string): string {\n  return model.startsWith('models/') ? model : `models/${model}`;\n}\n\nfunction extractGoogleText(response: GenerateContentResponse): string {\n  const parts: string[] = [];\n  for (const candidate of response.candidates ?? []) {\n    const candidateParts = candidate.content?.parts ?? [];\n    for (const part of candidateParts) {\n      if ('text' in part && typeof part.text === 'string') {\n        parts.push(part.text);\n      }\n    }\n  }\n  return parts.join('');\n}\n\nfunction normalizeGoogleError(error: unknown): Error {\n  const numericCode = typeof (error as { code?: number }).code === 'number' ? (error as { code?: number }).code : undefined;\n  const httpStatus = typeof (error as { status?: number }).status === 'number' ? (error as { status?: number }).status : undefined;\n  const grpcStatus = typeof (error as { status?: string }).status === 'string' ? (error as { status?: string }).status : undefined;\n  const statusMessage = typeof (error as { statusMessage?: string }).statusMessage === 'string'\n    ? (error as { statusMessage?: string }).statusMessage\n    : undefined;\n\n  const baseMessage = error instanceof Error ? error.message : String(error);\n\n  if (baseMessage.trim().toLowerCase().startsWith('google:')) {\n    return new Error(baseMessage);\n  }\n\n  if (\n    httpStatus === 401 ||\n    httpStatus === 403 ||\n    grpcStatus === 'UNAUTHENTICATED' ||\n    grpcStatus === 'PERMISSION_DENIED' ||\n    numericCode === 7 ||\n    numericCode === 16\n  ) {\n    return new Error('google: falha de autenticação. Confere GOOGLE_API_KEY e habilita o Gemini.');\n  }\n\n  if (\n    httpStatus === 408 ||\n    httpStatus === 504 ||\n    grpcStatus === 'DEADLINE_EXCEEDED' ||\n    grpcStatus === 'UNAVAILABLE' ||\n    numericCode === 4 ||\n    numericCode === 14\n  ) {\n    return new Error('google: tempo limite ou indisponibilidade. Chamando fallback.');\n  }\n\n  if (httpStatus === 429 || grpcStatus === 'RESOURCE_EXHAUSTED' || numericCode === 8) {\n    return new Error('google: cota ou rate limit batendo forte. Espera um pouco ou troca de provedor.');\n  }\n\n  if (error instanceof Error) {\n    const errno = (error as NodeJS.ErrnoException).code;\n    if (errno === 'ETIMEDOUT' || errno === 'ESOCKETTIMEDOUT') {\n      return new Error('google: conexão expirou. Partiu fallback.');\n    }\n    if (errno === 'ECONNREFUSED' || errno === 'ECONNRESET') {\n      return new Error('google: conexão com a API falhou. Tenta outro provider rapidinho.');\n    }\n  }\n\n  if (statusMessage && statusMessage.trim() !== '') {\n    return new Error(`google: ${statusMessage}`);\n  }\n\n  return new Error(`google: ${baseMessage}`);\n}\n\nasync function createGoogleClient(apiKey?: string): GoogleClientPromise {\n  const trimmed = apiKey?.trim();\n  if (!trimmed) {\n    throw new Error('google: chave de API não configurada. Define GOOGLE_API_KEY.');\n  }\n\n  const authClient = await new GoogleAuth().fromAPIKey(trimmed);\n  return new GenerativeServiceClient({ authClient });\n}\n\nexport function createGoogleProvider(options?: GoogleProviderOptions): ProviderHandler {\n  const apiKey = options?.apiKey ?? process.env.GOOGLE_AI_API_KEY;\n  const clientPromise: GoogleClientPromise | null = apiKey && apiKey.trim() !== ''\n    ? createGoogleClient(apiKey).catch((error) => {\n        throw normalizeGoogleError(error);\n      })\n    : null;\n\n  return async ({ prompt, decision, parameters }) => {\n    if (!clientPromise) {\n      throw new Error('google: chave de API não configurada. Define GOOGLE_API_KEY.');\n    }\n\n    let client: GenerativeServiceClient;\n    try {\n      client = await clientPromise;\n    } catch (error) {\n      throw normalizeGoogleError(error);\n    }\n\n    const generationConfig: { maxOutputTokens?: number; temperature?: number } = {};\n    if (typeof parameters.max_output_tokens === 'number') {\n      generationConfig.maxOutputTokens = parameters.max_output_tokens;\n    }\n    if (typeof parameters.temperature === 'number') {\n      generationConfig.temperature = parameters.temperature;\n    }\n\n    const request: Parameters<GenerativeServiceClient['generateContent']>[0] = {\n      model: ensureModelName(decision.model),\n      contents: [\n        {\n          role: 'user',\n          parts: [\n            {\n              text: prompt,\n            },\n          ],\n        },\n      ],\n      ...(Object.keys(generationConfig).length > 0 ? { generationConfig } : {}),\n    };\n\n    try {\n      const [response] = await client.generateContent(request);\n      const outputText = extractGoogleText(response) ?? '';\n      const usage = response.usageMetadata;\n\n      return {\n        outputText,\n        usage: usage\n          ? {\n              inputTokens: usage.promptTokenCount,\n              outputTokens: usage.candidatesTokenCount,\n              totalTokens: usage.totalTokenCount,\n            }\n          : undefined,\n        raw: response,\n      };\n    } catch (error) {\n      throw normalizeGoogleError(error);\n    }\n  };\n}\n","import OpenAI, { APIError as OpenAIAPIError } from 'openai';\nimport type { ProviderHandler } from '../delegate';\n\nexport interface OpenAIProviderOptions {\n  apiKey?: string;\n}\n\nfunction buildOpenAIClient(apiKey?: string): OpenAI | null {\n  if (!apiKey || apiKey.trim() === '') {\n    return null;\n  }\n  return new OpenAI({ apiKey });\n}\n\nfunction normalizeOpenAIError(error: unknown): Error {\n  if (error instanceof OpenAIAPIError) {\n    if (error.status === 401 || error.status === 403) {\n      return new Error('openai: falha de autenticação. Confere OPENAI_API_KEY e permissões.');\n    }\n    if (error.status === 408) {\n      return new Error('openai: tempo limite excedido ao gerar resposta. Tenta de novo daqui a pouco.');\n    }\n    if (error.status === 429) {\n      return new Error('openai: limite de requisições atingido. Aguarda um pouco antes de tentar de novo.');\n    }\n    return new Error(`openai: ${error.message}`);\n  }\n\n  if (error instanceof Error) {\n    const timeoutCodes = new Set(['ETIMEDOUT', 'ESOCKETTIMEDOUT']);\n    const networkCodes = new Set(['ECONNRESET', 'ECONNREFUSED']);\n    const code = (error as NodeJS.ErrnoException).code;\n    if (code && timeoutCodes.has(code)) {\n      return new Error('openai: tempo limite na conexão. Tenta novamente em instantes.');\n    }\n    if (code && networkCodes.has(code)) {\n      return new Error('openai: conexão com a API falhou. Dá uma conferida e tenta outra rota.');\n    }\n    return new Error(`openai: ${error.message}`);\n  }\n\n  return new Error(`openai: falha inesperada (${String(error)})`);\n}\n\nexport function createOpenAIProvider(options?: OpenAIProviderOptions): ProviderHandler {\n  const client = buildOpenAIClient(options?.apiKey);\n\n  return async ({ prompt, decision, parameters }) => {\n    if (!client) {\n      throw new Error('openai: chave de API não configurada. Define OPENAI_API_KEY.');\n    }\n\n    try {\n      const response = await client.responses.create({\n        model: decision.model,\n        input: prompt,\n        temperature: parameters.temperature,\n        max_output_tokens: parameters.max_output_tokens,\n      });\n\n      const outputText = typeof response.output_text === 'string'\n        ? response.output_text\n        : Array.isArray(response.output)\n          ? response.output\n              .map((item) => {\n                if (item.type === 'output_text' && typeof item.text === 'string') {\n                  return item.text;\n                }\n                return '';\n              })\n              .join('')\n          : '';\n\n      return {\n        outputText,\n        usage: {\n          inputTokens: response.usage?.input_tokens,\n          outputTokens: response.usage?.output_tokens,\n          totalTokens: response.usage?.total_tokens,\n        },\n        raw: response,\n      };\n    } catch (error) {\n      throw normalizeOpenAIError(error);\n    }\n  };\n}\n","import type { DelegateContext, ProviderHandler } from '../delegate';\nimport { createAnthropicProvider } from './anthropic';\nimport { createGoogleProvider } from './google';\nimport { createOpenAIProvider } from './openai';\n\nexport interface ProvidersEnvConfig {\n  openaiApiKey?: string;\n  anthropicApiKey?: string;\n  googleApiKey?: string;\n}\n\nexport function createProvidersFromEnv(config?: ProvidersEnvConfig): Record<string, ProviderHandler> {\n  const openaiKey = config?.openaiApiKey ?? process.env.OPENAI_API_KEY;\n  const anthropicKey = config?.anthropicApiKey ?? process.env.ANTHROPIC_API_KEY;\n  const googleKey = config?.googleApiKey ?? process.env.GOOGLE_API_KEY ?? process.env.GOOGLE_AI_API_KEY;\n\n  return {\n    openai: createOpenAIProvider({ apiKey: openaiKey }),\n    anthropic: createAnthropicProvider({ apiKey: anthropicKey }),\n    google: createGoogleProvider({ apiKey: googleKey }),\n  };\n}\n\nexport function createDelegateContext(logger?: DelegateContext['logger']): DelegateContext {\n  return {\n    providers: createProvidersFromEnv(),\n    logger,\n  };\n}\n"],"mappings":"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","names":["modelInfo","resolved","policyCap","targetCap","maxOutputTokens","temperature","logger","buildPrompt","buildRouteRequest","buildPrompt","buildRouteRequest","logger"]}